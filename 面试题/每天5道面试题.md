# 2022.8.26
### 46. computed 的实现原理
> computed 本质是一个惰性求值的观察者computed watcher。其内部通过 this.dirty 属性标记计算属性是否需要重新求值。
> 1. 当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,computed watcher 通过 this.dep.subs.length 判断有没有订阅者
> 2. 有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)
> 3. 没有的话,仅仅把 this.dirty = true (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)

#### 记忆关键点
1. computed的依赖状态发生变化时，会通知watcher
2. watcher判断有没有订阅者
3. 有订阅者的话重新计算computed的返回值和旧值进行对比，不一样就重新渲染。

### 47. Vue.nextTick()原理
> 在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM

#### 记忆关键点：
就是vue响应式更新了dom之后执行nextTick的函数回调

### 48. vue响应式性能优化
vue响应式的性能优化是在一个event loop周期内的派发更新操作放到队列中后一次执行队列中的所有操作，类似节流只是时间周期是一个event loop。优化data中的属性值频繁改变带来的性能消耗。

### 49. vue使用Object.defineProperty() 的缺陷
> 数组的length属性被初始化configurable false，所以想要通过get/set方法来监听length属性是不可行的。
vue中通过重写了七个能改变原数组的方法来进行数据监听
对象还是使用Object.defineProperty()添加get和set来监听

#### 记忆关键点：
1. 监听不了length，因为length的configurable为false。configurable是设置对象的属性是否可以删除，是否可以修改属性的特性，是否修改为访问器属性。
（个人理解：就是length不能添加getter和setter变为访问器属性）
2. 重新数组的七个改变数组的方法来监听

### 50. vue 响应式系统
> vue 初始化时会用Object.defineProperty()给data中每一个属性添加getter和setter，同时创建dep和watcher进行依赖收集与派发更新，最后通过diff算法对比新老vnode差异，通过patch即时更新DOM。

#### 记忆关键点：
1. 用defineProperty给打data添加getter和setter
2. 创建dep类来进行依赖收集
3. 创建watcher类来进行派发更新
4. 通过diff算法来对比新旧vnode
5. 通过patch更新dom

# 2022.8.25
### 41. Vue 中的 key 到底有什么用
> key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速

#### 记忆关键点：
key是用来在diff算法的时候找到是不是同一个节点的一个依据。

### 42. vue生命周期
> 1. beforeCreate是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。
> 2. created在实例创建完成后发生。
> 3. beforeMount发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。
> 4. mounted在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。
> 5. beforeUpdate发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发。
> 6. updated发生在更新完成之后，当前阶段组件Dom已完成更新。
> 7. beforeDestroy发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
> 8. destroyed发生在实例销毁之后，这个时候只剩下了dom空壳。

#### 记忆关键点：
1. beforeCreate：在对象创建执行执行，this里面的方法属性都不能访问
2. created:对象创建之后执行，this里面的方法属性可以访问
3. beforeMount：挂载之前执行，vnode已经生成还没渲染
4. mounted：挂载之后执行，可以访问模板里面的dom节点
5. buforeUpdate：更新视图之前执行，vnode渲染之前触发
6. updated：更新视图之后执行，vnode渲染之后触发
7. beforeDestroy：对象摧毁之前执行
8. destroyed：对象摧毁之后执行

### 43. vue 渲染过程
> 1. 调用 compile 函数,生成 render 函数字符串 ,编译过程如下
>     - parse 使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。
>    - ptimize 遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能
>    - generate 将最终的AST转化为render函数字符串
> 2. 调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象
> 3. 调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素

#### 记忆关键点：
1. 将template字符通过正则表达式转化为抽象语法树AST
2. 对AST中的静态节点进行标记，优化diff对比操作
3. 将AST转化为生成vnode的render函数代码字符串
4. 通过dep类和watcher类进行依赖收集和派发更新，执行render函数生成vnode对象
5. 通过diff算法对比vnode更新真实的dom

### 44. vue diff 算法
> 1. 只对比父节点相同的新旧子节点（比较的是Vnode）,时间复杂度只有O(n) 对比过程:
>    - 先找到 不需要移动的相同节点，借助key值找到可复用的节点是，消耗最小
>    - 再找相同但是需要移动的节点，消耗第二小
>    - 最后找不到，才会去新建删除节点，保底处理
> 2. 在 diff 比较的过程中，循环从两边向中间收拢

#### 记忆关键点：
1. 对比相同父节点的子节点，对比过程是从两边向中间收拢
2. 先找到不需要移动的节点，通过key值
3. 在找相同的需要移动的节点
4. 在找需要删除和新建的节点

### 45. watch 的理解
> watch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听。这样会带 来性能问题，优化的话可以使用字符串形式监听

#### 记忆关键点：
1. watch没有缓存性
2. 监听某些数据的回调函数

# 2022.8.24
### 36. 从浏览器地址栏输入url到请求返回发生了什么
> 首先会进行 url 解析，根据 dns 系统进行 ip 查找，查找到IP之后，就是http协议的三次握手（以及后面会涉及到四次分手），建立完链接，就该请求html文件了，如果html文件在缓存里面浏览器直接返回，如果没有，就去后台拿，解析html

#### 记忆关键点：
1. 解析url
2. 根据dns查找ip
3. 三次握手建立链接
4. 请求html
5. 判断缓存
6. 解析html

### 37. 为什么url要解析（也就是编码)
> 因为网络标准规定了URL只能是字母和数字，还有一些其它特殊符号，而且如果不转义会出现歧义。

#### 记忆关键点：
对url的特殊字符进行转义

### 38. 说一说keep-alive实现原理
> keep-alive实例会缓存对应组件的VNode,如果命中缓存，直接从缓存对象返回对应VNode
keep-alive组件接受三个属性参数：include、exclude、max
> 1. include 指定需要缓存的组件name集合，参数格式支持String, RegExp, Array。当为字符串的时候，多个组件名称以逗号隔开。
> 2. exclude 指定不需要缓存的组件name集合，参数格式和include一样。
> 3. max 指定最多可缓存组件的数量,超过数量删除第一个。参数格式支持String、Number。

#### 记忆关键点：
缓存组件的vnode。

属性：include指定要缓存的组件名称，exclude指定不要缓存的组件名称，max指定最多缓存组件的数量。

### 39. vue-router 路由模式有几种
> 1. hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器
> 2. history: 依赖 HTML5 History API 和服务器配置。
> 3. abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

#### 记忆关键点：
1. hash模式使用URL锚点不会刷新页面的原理
2. history: 依赖 HTML5 History API ，修改url地址不会刷新页面

### 40. vue-router 路由的原理
1. hash值改变会触发hashchange事件，通过这个事件监听hash的变化来判断路由跳转和显示页面
2. html5多了两个api，pushState(创建历史记录）和replaceState(修改)，通过这两个api可以改变url地址并且不会发送请求，点击后退、前进按钮会触发onpopState()

# 2022.8.23
### 32. 缓存解释一下
> 1. 浏览器首次加载资源成功时，服务器返回200，此时浏览器不仅将资源下载下来，而且把response的header(里面的date属性非常重要，用来计算第二次相同资源时当前时间和date的时间差)一并缓存;
> 2. 下一次加载资源时，首先要经过强缓存的处理，cache-control的优先级最高，比如cache-control：no-cache,就直接进入到协商缓存的步骤了，如果cache-control：max-age=xxx,就会先比较当前时间和上一次返回200时的时间差，如果没有超过max-age，命中强缓存，不发请求直接从本地缓存读取该文件（这里需要注意，如果没有cache-control，会取expires的值，来对比是否过期），过期的话会进入下一个阶段，协商缓存
> 3. 协商缓存阶段，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，服务器会比较Etag，如果相同，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200;
> 4. 协商缓存第二个重要的字段是，If-Modified-Since，如果客户端发送的If-Modified-Since的值跟服务器端获取的文件最近改动的时间，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200;

### 个人总结：
强缓存：当页面是第一次请求时不会有强缓存，二次以上的请求会进行强缓存判断。判断规则如下
1. 强缓存是根据第一次响应返回的expires和cache-control字段来判断的。
2. cache-control规则特点：
   - HTTP1.1的强缓存字段，优先级高于expires；
   - 值为public：资源客户端和服务器都可以缓存；
   - 值为privite：资源只有客户端可以缓存；
   - 值为no-cache：客户端缓存资源，但是缓存需要经过协商缓存来验证；
   - 值为no-store：不使用缓存；
   - 值为max-age：缓存保质期，使用的是相对时间，解决了expires的缺点
3. expires：HTTP1.0的强缓存字段，值为一个时间戳指强缓存的到期时间，有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的还有时区的不同   

协商缓存：页面是第一次请求时不会有协商缓存，协商缓存规则如下
1. Etag / If-None-Match（高优先级）
   - Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
   - If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。
   - Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。
   - 缺点：唯一标识是服务器生成的，当访问的人比较多时会对服务器产生一定的负担。
2. Last-Modified / If-Modified-Since（低优先级）
   - Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
   - If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，服务器会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。
   - 缺点：服务器的文件没做修改再保存，文件的修改时间也会变导致即使文件内容没变协商缓存失效。
3. 缓存方案
   - HTML: 协商缓存
   - css、js、图片：强缓存，文件名带上hash
### 33. 说三次握手，为啥两次不行，顺便说一下3次握手发生了什么
> 1. 第一次握手：主机A发送位码为SYN＝1的TCP包给服务器，并且随机产生一个作为确认号（这是tcp包的一部分），主机B收到SYN码后直到A要求建立连接;
> 2. 第二次握手：主机B收到请求后，向A发送确认号（主机A的seq+1），syn=1，seq = 随机数 的TCP包；
> 3. 主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1，若正确，主机A会再发送确认号(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

接着补上小问题为什么两次握手不行，因为第二次握手，主机B还不能确认主机A已经收到确认请求，也是说B认为建立好连接，开始发数据了，结果发出去的包一直A都没收到，那攻击B就很容易了，我专门发包不接收，服务器很容易就挂了。

#### 记忆关键点：
1. 客户端给服务器发送一个SYN段TCP数据包，请求建立连接
2. 服务器收到请求数据包后，会发送给客户端确认号的TCP数据包
3. 客户端收到服务器的数据包后，检查确认号是否正确，正确的话会给服务器发送确认号数据包，服务器检查收到的确认号，正确的话建立连接成功

### 34. 说说dns解析流程，并且html如何做dns优化
> 1. 器中输入https://www.baidu.com 域名，操作系统会先查hosts件是否有记录，有的话就会把相对应映射的IP返回。
> 2. hosts文件没有就去查本地dns解析器有没有缓存。（这个我没答上来）
> 3. 然后就去找我们计算机上配置的dns服务器上有或者有缓存，就返回
> 4. 还没有的话就去找根DNS服务器(全球13台，固定ip地址)，然后判断.com域名是哪个服务器管理，如果无法解析，就查找.baidu.com服务器是否能解析，直到查到www.baidu.com的IP地址

#### 个人总结：
1. 浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有的返回ip地址，如果没有进入下一步。
2. 操作系统查hosts文件是否有记录，有的话返回ip地址，如果没有进入下一步
3. 请求本地设置的域名服务器（LDNS）来解析这个域名，如果有的话返回ip地址，如果没有进入下一步。
4. 请求根域名服务器，返回域服务器地址
5. 请求域服务器，返回域名的解析服务器的地址
6. 请求域名的解析服务器，返回对应的ip地址

### 35. CND是什么
CND名叫内容分发网络，原理：这个域名对应的是CNAME,然后继续找CNAME域名对应的ip地址，返回对应ip地址
具体实现：给静态资源的域名配置一个CNAME,这个CNAME指向CND专用DNS服务器，然后域名解析转交给专用dns服务器解析，专用服务器根据id地址所在的地理位置找离用户最近的DNS服务器地址，返回给用户，用户就能访问最近的cdn服务器了。

# 2022.8.22
### 26. 说一下v-if和v-show的区别
> 当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。在使用 v-show 的时候，所有分支内部的组件都会渲染，对应的生命周期钩子函数都会执行，而使用 v-if 的时候，没有命中的分支内部的组件是不会渲染的，对应的生命周期钩子函数都不会执行。
#### 记忆关键点：
1. v-if不会渲染DOM元素，v-show操作的是样式(display)
2. v-show一开始就会执行组件的初始化操作
3. v-if为false不会执行组件的初始化操作
4. 频繁显示隐藏的组件，v-if每次都要执行组件初始化操作性能消耗大些

### 27. 再说一下Computed和Watch
> Computed本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。
Watch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。
### 记忆关键点：
1. computed有缓存性，依赖变化会更新视图
2. watch没有缓存性，监听数据的执行回调

### 28. 重绘和重排是什么
 1. 重排    
     - 定义：元素的几何属性（尺寸大小、布局位置、盒子模型）、DOM结构改变时引发渲染树重新生成的过程
     - 重排是页面重新触发了布局
     - 触发条件
       - 添加或删除可见的DOM元素
       - 几何属性变化（尺寸大小、布局位置、盒子模型）
       - 内容变化
       - 读取元素的布局信息：浏览器性能优化会将DOM元素的修改操作放到队列中，一段时间后或者操作达到一定值才执行队列里面的操作，当获取布局信息时要先执行队列里面的操作后才获取到精确的值，所有浏览器会执行一次重排和重绘。
       - 浏览器窗口尺寸改变
       -  激活CSS伪类
 2. 重绘
    - 元素的绘制属性改变，重新绘制元素的过程
    - 外观属性：背景、边框、圆角、透明度、字体相关属性
    - 重绘是页面没有触发布局而是触发绘制
 3. 扩展
    - 没有设置图片大小时，图片加载完后会触发回流和重绘，开始设置了图片大小就只会触发重绘
    - 透明度什么情况下触发会重绘
       - opacity值变为1时触发layout和paint
       - opacity值变为0时不触发layout 、触发paint
       - 其他值的改变不触发layout和paint
       - 把元素提升到合成层之后opacity的改变不触发layout和paint

### 29. 重绘重排的性能优化
1.   visibility:hidden替换display:none
  a.  display:none不占据空间，visibility:none占据空间，要根据具体功能情况来替换，弹窗可以使用visibility:none因为脱离了文档流，而在文档流中的元素隐藏要注意占空间的问题。
  b.  display:none：影响过渡不影响动画，visibility:hidden：过渡和动画都不影响（没理解）
2.   避免使用Table布局（促发）
3.   避免设置多层内联样式（重排和重绘效率,因为css解析是从右到左的）
4.   将频繁重绘或重排的节点设置为合成层（重新渲染不影响其他节点，重排和重绘效率）
5.   使用requestAnimationFrame作为动画帧（浏览器的刷新频率设置动画，减少多余的重排和重绘次数）
6.   对于复杂动画效果,使用绝对定位让其脱离文档流（重新渲染不影响其他节点，重排和重绘效率，脱离文档流不会影响父元素和兄弟元素的重排和重绘）
7.   动态改变类而不改变样式（减少多余的重排和重绘次数）
8.   批量修改DOM可以让dom先隐藏（可以通过display:none或者js复制dom对象修改完了之后在放到文档中）dom隐藏和放回文档中回触发重排重绘，但修改的过程不会触发（减少重排重绘次数）
9.   使用CSS3硬件加速，可以让 transform、opacity、filters这些动画不会引起重拍重绘

### 30. 浏览器怎么解析html
> 1. 构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；
> 2. 构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；
> 3. 执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；
> 4. 构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；
> 5. 渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。
> 6. 布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；
> 7. 绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成； 

#### 个人总结：
1. 根据html构建dom树，扩展：
   - js文件的下载会阻塞html的解析，css的下载不会阻塞html解析，但是js前面有css的话，css下载会阻塞js的执行，而能间接阻塞html的解析
   - 预加载扫描器（解析html过程中提前解析要加载的资源）
   - css不会阻塞html解析，会阻塞html渲染，因为渲染树是通过dom树和cssom树生成的
   - 静态文件加载优化方案
      - CDN 加速，减少加载时间
      - css压缩，减少css文件大小
      - 合理使用缓存，减少请求次数
      - 合并css文件，减少请求次数
2. 解析css生成CSSOM树：和解析html互不影响
3. style：将DOM和CSSOM组合成一个Render树，构建渲染树
4. Layout(布局)：在渲染树上确定元素的宽、高、位置生成布局树
5. Paint：绘制，将元素样式绘制在屏幕上，该阶段包括分层和栅格化
   - 渲染树不是每个节点都有图层，拥有层叠上下文（可扩展）的属性会被提升为单独的一层，需要剪裁（clip）的地方也会被创建为图层，超出显示区域产生裁剪会单独创建一个图层 ，滚动条也会被提升为单独的图层
   - 层叠上下文就是 HTML 元素基于其元素属性按照优先级顺序占据这个空间，形成条件
      - 文档根元素
      - 绝对定位、相对定位且 z-index 值不为 auto 的元素
      - 固定定位、粘滞定位的元素
      - flex 容器的子元素且 z-index 值不为 auto
      - grid (grid) 容器的子元素且 z-index 值不为 auto
      - opacity 属性值小于 1 的元素
      - transform不为none的元素
      - will-change 值设定了任一属性而该属性在 non-initial 值时（可扩展）会创建层叠上下文的元素
   - 栅格化（tiles-分图块、raster-栅格化将图块转化为位图）
      - 合成线程将图层划分成图块，先将视口附近的图块栅格化生成位图。栅格化会使用GPU硬件加速生成位图，保存到GPU内存中。（GPU 操作在 GPU 进程中，栅格化在渲染进程中，这个过程涉及跨进程操作。）
   - compositing合成
      - 合成，将相互层叠的不同层进行合成
      - 一定属性的渲染层会被提升为合成层
        - transform: translateZ(0)为提升合成层， translateX 或 translateY不会
        - backface-visibility: hidden
        - will-change
        - video、canvas、iframe 等元素
      - 合成层是单独的图层和其他图层互不影响
      - 隐式合成：在合成元素之上的非合成元素会被提升为合成层（隐式合成可能会使浏览器有很多合成层导致层爆炸，但新版谷歌浏览器优化采用层压缩）
   - 合成层优点
      - 合成层的位图会交由 GPU 合成，相比 CPU 处理要快
      - 合成层发生 repaint 的时候，不会影响其他图层
      - 对于 transform 和 opacity 效果，不会触发 layout 和 paint
    - 合成层缺点：渲染内存占用比大幅度提升。会让页面变的卡顿
    - will-change注意的点：任何带有 position: fixed 或者 position: absolute 的子元素将会相对于设置了 will-change: transform 的元素进行相对定位，will-change会 耗费更多的资源
 


# 2022.8.20
### 21. Vue2.x组件通信有哪些方式
> 父子组件通信
父->子props，子->父 $on、$emit
获取父子组件实例 $parent、$children
Ref 获取实例的方式调用组件的属性或者方法
Provide、inject 官方不推荐使用，但是写组件库时很常用
兄弟组件通信
Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue
Vuex
跨级组件通信
Vuex
$attrs、$listeners
Provide、inject
#### 记忆关键点
1. props、$emit、$on
2. $parent、$children
3. ref
4. Provide、inject
5. Event Bus
6. Vuex
7. $attrs、$listeners

### 22. Vue中组件生命周期调用顺序说一下
> 加载渲染过程<br>
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted<br>
组件更新过程<br>
父beforeUpdate->子beforeUpdate->子updated->父updated<br>
销毁过程<br>
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

### 23. Vue事件绑定原理说一下
> 原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。

### 24. 说一下v-model的原理
> v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

#### 记忆关键点
v-model是语法糖，是value属性和input事件组合效果，即值通过prop value属性传给子组件，执行emit input事件将新值传回父组件

### 25. 组件中的data为什么是一个函数
> 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。
#### 记忆关键点
data是一个对象，引用类型，如果不是一个函数，组件的所有实例的data都会指向同一个对象。
# 2022.8.19

### 16. addEventListener函数的第三个参数
> 第三个参数涉及到冒泡和捕获，是true时为捕获，是false则为冒泡。
或者是一个对象{passive: true}，针对的是Safari浏览器，禁止/开启使用滚动的时候要用到。

### 17. 描述一下EventLoop的执行过程
> 1. 一开始整个脚本作为一个宏任务执行
> 2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
> 3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
> 4. 执行浏览器UI线程的渲染工作
> 5. 检查是否有Web Worker任务，有则执行
> 6. 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

### 18. Promise为什么能链式调用
> 由于它的then方法和catch、finally方法会返回一个新的Promise所以可以允许我们链式调用

### 19. 描述一下Promise
> Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的then方法和catch、finally方法会返回一个新的Promise所以可以允许我们链式调用，解决了传统的回调地狱问题。

#### 记忆关键点
then方法返回新的promise可以链式调用，解决回调炼狱问题。

### 20. 你都做过哪些Vue的性能优化
> 1. 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
> 2. v-if和v-for不能连用
> 3. 如果需要使用v-for给每项元素绑定事件时使用事件代理
> 4. SPA 页面采用keep-alive缓存组件
> 5. 在更多的情况下，使用v-if替代v-show
> 6. key保证唯一
> 7. 使用路由懒加载、异步组件
> 8. 防抖、节流
> 9. 第三方模块按需导入
> 10. 长列表滚动到可视区域动态加载
> 11. 图片懒加载

#### 个人总结

1. vue2中函数组件性能更好，因为函数组件没有被看成真正的组件，不会递归子组件初始化，没有状态、响应式、生命周期通过函数渲染出来的，所以省略了很多处理处理操作，在vue3中官方说函数组件带来的性能比较小，推荐使用有状态的组件
2. 拆分子组件，因为vue是按组件来更新的，父组件的重新渲染，子组件没有数据变化的化不会重新渲染。性能优化了
3. 在函数中将双向绑定的变量赋值为局部变量，然后在用局部变量进行操作，最后在赋值到双向绑定的变量中，这样会减少响应式的处理次数
4. v-show和v-if根据使用场景合理利用，当组件在初始化判断是否显示后不会在改变的情况v-if更合适，因为v-if符合条件的组件会渲染，不符合的组件不会渲染，v-show两个组件都会渲染所以v-if的性能会高点，而如果是弹窗那种后期操作会重复显示隐藏的v-show的更合适，因为v-if的话每次显示组件都会重新走一遍初始化。
5. 路由加keepAlive缓存组件，减少组件初始化次数
6. 延迟分批渲染组件，异步加载组件
7. 数据量比较多的情况下用虚拟滚动

# 2022.8.18
### 11. 函数内的this是在什么时候确定的？
> 函数调用时，指向最后调用的那个对象

### 12. typeof为什么对null错误的显示
> 这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

### 13. typeof和instanceof的区别
> typeof表示是对某个变量类型的检测，基本数据类型除了null都能正常的显示为对应的类型，引用类型除了函数会显示为'function'，其它都显示为object。
而instanceof它主要是用于检测某个构造函数的原型对象在不在某个对象的原型链上。

#### 记忆关键点：
typeof检测基本数据类型，但是null返回的是object，函数会返回function的
instanceof是检测对象是否是某个构造函数实例化的。

### 14. js中event的target和currentTarget
> target指向被点击的对象，而currentTarget指向当前事件活动的对象，通常是事件的祖元素。

### 15. 冒泡和捕获的具体过程
> 冒泡指的是：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发(当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了click事件就触发父元素的click)。
捕获则是从上层向下层传递，与冒泡相反。

# 2022.8.17
### 6. 浏览器为什么要跨域？如果是因为安全的话那小程序或者其他的为什么没有跨域？
> 跨域的产生来源于现代浏览器所通用的同源策略，所谓同源策略，是指只有在地址的：协议名、域名、端口名，
均一样的情况下，才允许访问相同的cookie、localStorage，以及访问页面的DOM或是发送Ajax请求。若在不同源的情况下访问，就称为跨域。
#### 记忆关键点：
跨域是浏览器的同源策略，指地址的协议名、域名、端口名不一样就是跨域，跨域不允许访问cookie、localSorage、ajax。

### 7. JSONP的原理
> 基本原理：主要就是利用 script 标签的src属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 Javascript 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完.

#### 记忆关键点：
利用script标签没有跨域的限制，src指向一个服务器地址，这个地址返回一个定义好的函数执行代码，数据以该函数参数的形式传递。

### 8. TCP和UDP的区别
> TCP是一个面向连接的、可靠的、基于字节流的传输层协议 <br>
UDP是一个面向无连接的传输层协议。 <br>
TCP为什么可靠，是因为它有三次握手来保证双方都有接受和发送数据的能力。 <br>
字节流服务：将大块数据分割为以报文段为单位的数据包进行管理

#### 记忆关键点：
1. TCP是一个面向连接的、可靠的、基于字节流的传输层协议。
2. UDP是一个面向无连接的传输层协议。

### 9. HTTP和TCP的不同
> HTTP的责任是去定义数据，在两台计算机相互传递信息时，HTTP规定了每段数据以什么形式表达才是能够被另外一台计算机理解。<br>
而TCP所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。

#### 记忆关键点：
1. http是定义数据的表达形式
2. tcp是定义数据的传输

### 10. webpack中的loader和plugin有什么区别
> loader它是一个转换器，只专注于转换文件这一个领域，完成压缩、打包、语言编译，它仅仅是为了打包。并且运行在打包之前。<br>
而plugin是一个扩展器，它丰富了webpack本身，为其进行一些其它功能的扩展。它不局限于打包，资源的加载，还有其它的功能。所以它是在整个编译周期都起作用。

#### 记忆关键点：
1. loader是一个转换器，完成压缩、打包、语音编译运行在打包之前
2. plugin是一个扩展器，扩展一些其他功能，在整个编译周期都起作用

# 2022.8.16
### 1. CORS跨域的原理
> 跨域资源共享(CORS)是一种机制，是W3C标准。它允许浏览器向跨源服务器，发出XMLHttpRequest或Fetch请求。并且整个CORS通信过程都是浏览器自动完成的，不需要用户参与。
而使用这种跨域资源共享的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种"跨域"请求。因此实现CORS的关键是服务器需要服务器。通常是有以下几个配置：
Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers、Access-Control-Allow-Credentials、Access-Control-Max-Age

#### 记忆关键点：
cors是一种跨域机制，一般要后端支持设置Access-Control-Allow-Origin

### 2. CORS请求分了哪两种请求
> 浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-simple-request），简单请求浏览器请求不会触发预检请求，而非简单请求会触发预检请求,同时满足下列以下条件，就属于简单请求:
> 1. 请求方式只能是：GET、POST、HEAD
> 2. HTTP请求头限制这几种字段（不得人为设置集合之外的其他首部字段）
> 3. Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain
> 4. 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。
> 5. 请求中没有使用 ReadableStream 对象。

#### 记忆关键点：
简单请求和非简单请求。

简单请求不需要预检，非简单请求之前要发个预检请求。
简单请求条件：
-  请求方法只能是get、post、head
- http请求头限制
- content-type只能是表单和text

### 3. 非简单请求为什么要发OPTIONS预检请求?
>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

#### 记忆关键点：

先询问服务器，当前页面的域名是否在服务器的许可名单之中。

### 4. 实际项目中发起OPTIONS有什么影响？可以避免么？为什么？
> OPTIONS请求耗费了一定的时间，需减少OPTIONS请求。但不可以避免。因为：
> - 我们系统请求中除了GET/POST还有PUT,DELETE。
> - 我们系统有做业务模块权限，请求头里需要带有用户验证信息。
> - 我们的Content-Type绝大多数是application/json。

#### 记忆关键点：
预检会耗费一定的时间，但非简单请求不能避免：
1. 系统中会有put、delete请求
2. 请求会带用户的验证信息如token
3. 一般都是用json格式

### 5. 怎么减少预检的请求次数？

> 后端在请求的返回头部添加：Access-Control-Max-Age：（number）  可以被缓存多久，单位是秒。Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。

#### 记忆关键点：
Access-Control-Max-Age可以设置预检请求的缓存时间

