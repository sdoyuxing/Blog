# 2022.8.20
### 21. Vue2.x组件通信有哪些方式
> 父子组件通信
父->子props，子->父 $on、$emit
获取父子组件实例 $parent、$children
Ref 获取实例的方式调用组件的属性或者方法
Provide、inject 官方不推荐使用，但是写组件库时很常用
兄弟组件通信
Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue
Vuex
跨级组件通信
Vuex
$attrs、$listeners
Provide、inject
#### 记忆关键点
1. props、$emit、$on
2. $parent、$children
3. ref
4. Provide、inject
5. Event Bus
6. Vuex
7. $attrs、$listeners

### 22. Vue中组件生命周期调用顺序说一下
> 加载渲染过程<br>
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted<br>
组件更新过程<br>
父beforeUpdate->子beforeUpdate->子updated->父updated<br>
销毁过程<br>
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

### 23. Vue事件绑定原理说一下
> 原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。

### 24. 说一下v-model的原理
> v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

#### 记忆关键点
v-model是语法糖，是value属性和input事件组合效果，即值通过prop value属性传给子组件，执行emit input事件将新值传回父组件

### 25. 组件中的data为什么是一个函数
> 一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。
#### 记忆关键点
data是一个对象，引用类型，如果不是一个函数，组件的所有实例的data都会指向同一个对象。
# 2022.8.19

### 16. addEventListener函数的第三个参数
> 第三个参数涉及到冒泡和捕获，是true时为捕获，是false则为冒泡。
或者是一个对象{passive: true}，针对的是Safari浏览器，禁止/开启使用滚动的时候要用到。

### 17. 描述一下EventLoop的执行过程
> 1. 一开始整个脚本作为一个宏任务执行
> 2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
> 3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
> 4. 执行浏览器UI线程的渲染工作
> 5. 检查是否有Web Worker任务，有则执行
> 6. 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

### 18. Promise为什么能链式调用
> 由于它的then方法和catch、finally方法会返回一个新的Promise所以可以允许我们链式调用

### 19. 描述一下Promise
> Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。由于它的then方法和catch、finally方法会返回一个新的Promise所以可以允许我们链式调用，解决了传统的回调地狱问题。

#### 记忆关键点
then方法返回新的promise可以链式调用，解决回调炼狱问题。

### 20. 你都做过哪些Vue的性能优化
> 1. 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
> 2. v-if和v-for不能连用
> 3. 如果需要使用v-for给每项元素绑定事件时使用事件代理
> 4. SPA 页面采用keep-alive缓存组件
> 5. 在更多的情况下，使用v-if替代v-show
> 6. key保证唯一
> 7. 使用路由懒加载、异步组件
> 8. 防抖、节流
> 9. 第三方模块按需导入
> 10. 长列表滚动到可视区域动态加载
> 11. 图片懒加载

#### 个人总结

1. vue2中函数组件性能更好，因为函数组件没有被看成真正的组件，不会递归子组件初始化，没有状态、响应式、生命周期通过函数渲染出来的，所以省略了很多处理处理操作，在vue3中官方说函数组件带来的性能比较小，推荐使用有状态的组件
2. 拆分子组件，因为vue是按组件来更新的，父组件的重新渲染，子组件没有数据变化的化不会重新渲染。性能优化了
3. 在函数中将双向绑定的变量赋值为局部变量，然后在用局部变量进行操作，最后在赋值到双向绑定的变量中，这样会减少响应式的处理次数
4. v-show和v-if根据使用场景合理利用，当组件在初始化判断是否显示后不会在改变的情况v-if更合适，因为v-if符合条件的组件会渲染，不符合的组件不会渲染，v-show两个组件都会渲染所以v-if的性能会高点，而如果是弹窗那种后期操作会重复显示隐藏的v-show的更合适，因为v-if的话每次显示组件都会重新走一遍初始化。
5. 路由加keepAlive缓存组件，减少组件初始化次数
6. 延迟分批渲染组件，异步加载组件
7. 数据量比较多的情况下用虚拟滚动

# 2022.8.18
### 11. 函数内的this是在什么时候确定的？
> 函数调用时，指向最后调用的那个对象

### 12. typeof为什么对null错误的显示
> 这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。

### 13. typeof和instanceof的区别
> typeof表示是对某个变量类型的检测，基本数据类型除了null都能正常的显示为对应的类型，引用类型除了函数会显示为'function'，其它都显示为object。
而instanceof它主要是用于检测某个构造函数的原型对象在不在某个对象的原型链上。

#### 记忆关键点：
typeof检测基本数据类型，但是null返回的是object，函数会返回function的
instanceof是检测对象是否是某个构造函数实例化的。

### 14. js中event的target和currentTarget
> target指向被点击的对象，而currentTarget指向当前事件活动的对象，通常是事件的祖元素。

### 15. 冒泡和捕获的具体过程
> 冒泡指的是：当给某个目标元素绑定了事件之后，这个事件会依次在它的父级元素中被触发(当然前提是这个父级元素也有这个同名称的事件，比如子元素和父元素都绑定了click事件就触发父元素的click)。
捕获则是从上层向下层传递，与冒泡相反。

# 2022.8.17
### 6. 浏览器为什么要跨域？如果是因为安全的话那小程序或者其他的为什么没有跨域？
> 跨域的产生来源于现代浏览器所通用的同源策略，所谓同源策略，是指只有在地址的：协议名、域名、端口名，
均一样的情况下，才允许访问相同的cookie、localStorage，以及访问页面的DOM或是发送Ajax请求。若在不同源的情况下访问，就称为跨域。
#### 记忆关键点：
跨域是浏览器的同源策略，指地址的协议名、域名、端口名不一样就是跨域，跨域不允许访问cookie、localSorage、ajax。

### 7. JSONP的原理
> 基本原理：主要就是利用 script 标签的src属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 Javascript 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完.

#### 记忆关键点：
利用script标签没有跨域的限制，src指向一个服务器地址，这个地址返回一个定义好的函数执行代码，数据以该函数参数的形式传递。

### 8. TCP和UDP的区别
> TCP是一个面向连接的、可靠的、基于字节流的传输层协议 <br>
UDP是一个面向无连接的传输层协议。 <br>
TCP为什么可靠，是因为它有三次握手来保证双方都有接受和发送数据的能力。 <br>
字节流服务：将大块数据分割为以报文段为单位的数据包进行管理

#### 记忆关键点：
1. TCP是一个面向连接的、可靠的、基于字节流的传输层协议。
2. UDP是一个面向无连接的传输层协议。

### 9. HTTP和TCP的不同
> HTTP的责任是去定义数据，在两台计算机相互传递信息时，HTTP规定了每段数据以什么形式表达才是能够被另外一台计算机理解。<br>
而TCP所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。

#### 记忆关键点：
1. http是定义数据的表达形式
2. tcp是定义数据的传输

### 10. webpack中的loader和plugin有什么区别
> loader它是一个转换器，只专注于转换文件这一个领域，完成压缩、打包、语言编译，它仅仅是为了打包。并且运行在打包之前。<br>
而plugin是一个扩展器，它丰富了webpack本身，为其进行一些其它功能的扩展。它不局限于打包，资源的加载，还有其它的功能。所以它是在整个编译周期都起作用。

#### 记忆关键点：
1. loader是一个转换器，完成压缩、打包、语音编译运行在打包之前
2. plugin是一个扩展器，扩展一些其他功能，在整个编译周期都起作用

# 2022.8.16
### 1. CORS跨域的原理
> 跨域资源共享(CORS)是一种机制，是W3C标准。它允许浏览器向跨源服务器，发出XMLHttpRequest或Fetch请求。并且整个CORS通信过程都是浏览器自动完成的，不需要用户参与。
而使用这种跨域资源共享的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种"跨域"请求。因此实现CORS的关键是服务器需要服务器。通常是有以下几个配置：
Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers、Access-Control-Allow-Credentials、Access-Control-Max-Age

#### 记忆关键点：
cors是一种跨域机制，一般要后端支持设置Access-Control-Allow-Origin

### 2. CORS请求分了哪两种请求
> 浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-simple-request），简单请求浏览器请求不会触发预检请求，而非简单请求会触发预检请求,同时满足下列以下条件，就属于简单请求:
> 1. 请求方式只能是：GET、POST、HEAD
> 2. HTTP请求头限制这几种字段（不得人为设置集合之外的其他首部字段）
> 3. Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain
> 4. 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。
> 5. 请求中没有使用 ReadableStream 对象。

#### 记忆关键点：
简单请求和非简单请求。

简单请求不需要预检，非简单请求之前要发个预检请求。
简单请求条件：
-  请求方法只能是get、post、head
- http请求头限制
- content-type只能是表单和text

### 3. 非简单请求为什么要发OPTIONS预检请求?
>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

#### 记忆关键点：

先询问服务器，当前页面的域名是否在服务器的许可名单之中。

### 4. 实际项目中发起OPTIONS有什么影响？可以避免么？为什么？
> OPTIONS请求耗费了一定的时间，需减少OPTIONS请求。但不可以避免。因为：
> - 我们系统请求中除了GET/POST还有PUT,DELETE。
> - 我们系统有做业务模块权限，请求头里需要带有用户验证信息。
> - 我们的Content-Type绝大多数是application/json。

#### 记忆关键点：
预检会耗费一定的时间，但非简单请求不能避免：
1. 系统中会有put、delete请求
2. 请求会带用户的验证信息如token
3. 一般都是用json格式

### 5. 怎么减少预检的请求次数？

> 后端在请求的返回头部添加：Access-Control-Max-Age：（number）  可以被缓存多久，单位是秒。Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。

#### 记忆关键点：
Access-Control-Max-Age可以设置预检请求的缓存时间

