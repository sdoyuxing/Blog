# 2022.8.17
### 6. 浏览器为什么要跨域？如果是因为安全的话那小程序或者其他的为什么没有跨域？
> 跨域的产生来源于现代浏览器所通用的同源策略，所谓同源策略，是指只有在地址的：协议名、域名、端口名，
均一样的情况下，才允许访问相同的cookie、localStorage，以及访问页面的DOM或是发送Ajax请求。若在不同源的情况下访问，就称为跨域。
#### 记忆关键点：
跨域是浏览器的同源策略，指地址的协议名、域名、端口名不一样就是跨域，跨域不允许访问cookie、localSorage、ajax。

### 7. JSONP的原理
> 基本原理：主要就是利用 script 标签的src属性没有跨域的限制，通过指向一个需要访问的地址，由服务端返回一个预先定义好的 Javascript 函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完.

#### 记忆关键点：
利用script标签没有跨域的限制，src指向一个服务器地址，这个地址返回一个定义好的函数执行代码，数据以该函数参数的形式传递。

### 8. TCP和UDP的区别
> TCP是一个面向连接的、可靠的、基于字节流的传输层协议 <br>
UDP是一个面向无连接的传输层协议。 <br>
TCP为什么可靠，是因为它有三次握手来保证双方都有接受和发送数据的能力。 <br>
字节流服务：将大块数据分割为以报文段为单位的数据包进行管理

#### 记忆关键点：
1. TCP是一个面向连接的、可靠的、基于字节流的传输层协议。
2. UDP是一个面向无连接的传输层协议。

### 9. HTTP和TCP的不同
> HTTP的责任是去定义数据，在两台计算机相互传递信息时，HTTP规定了每段数据以什么形式表达才是能够被另外一台计算机理解。<br>
而TCP所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。

#### 记忆关键点：
1. http是定义数据的表达形式
2. tcp是定义数据的传输

### 10. webpack中的loader和plugin有什么区别
> loader它是一个转换器，只专注于转换文件这一个领域，完成压缩、打包、语言编译，它仅仅是为了打包。并且运行在打包之前。<br>
而plugin是一个扩展器，它丰富了webpack本身，为其进行一些其它功能的扩展。它不局限于打包，资源的加载，还有其它的功能。所以它是在整个编译周期都起作用。

#### 记忆关键点：
1. loader是一个转换器，完成压缩、打包、语音编译运行在打包之前
2. plugin是一个扩展器，扩展一些其他功能，在整个编译周期都起作用

# 2022.8.16
### 1. CORS跨域的原理
> 跨域资源共享(CORS)是一种机制，是W3C标准。它允许浏览器向跨源服务器，发出XMLHttpRequest或Fetch请求。并且整个CORS通信过程都是浏览器自动完成的，不需要用户参与。
而使用这种跨域资源共享的前提是，浏览器必须支持这个功能，并且服务器端也必须同意这种"跨域"请求。因此实现CORS的关键是服务器需要服务器。通常是有以下几个配置：
Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers、Access-Control-Allow-Credentials、Access-Control-Max-Age

#### 记忆关键点：
cors是一种跨域机制，一般要后端支持设置Access-Control-Allow-Origin

### 2. CORS请求分了哪两种请求
> 浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-simple-request），简单请求浏览器请求不会触发预检请求，而非简单请求会触发预检请求,同时满足下列以下条件，就属于简单请求:
> 1. 请求方式只能是：GET、POST、HEAD
> 2. HTTP请求头限制这几种字段（不得人为设置集合之外的其他首部字段）
> 3. Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain
> 4. 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。
> 5. 请求中没有使用 ReadableStream 对象。

#### 记忆关键点：
简单请求和非简单请求。

简单请求不需要预检，非简单请求之前要发个预检请求。
简单请求条件：
-  请求方法只能是get、post、head
- http请求头限制
- content-type只能是表单和text

### 3. 非简单请求为什么要发OPTIONS预检请求?
>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

#### 记忆关键点：

先询问服务器，当前页面的域名是否在服务器的许可名单之中。

### 4. 实际项目中发起OPTIONS有什么影响？可以避免么？为什么？
> OPTIONS请求耗费了一定的时间，需减少OPTIONS请求。但不可以避免。因为：
> - 我们系统请求中除了GET/POST还有PUT,DELETE。
> - 我们系统有做业务模块权限，请求头里需要带有用户验证信息。
> - 我们的Content-Type绝大多数是application/json。

#### 记忆关键点：
预检会耗费一定的时间，但非简单请求不能避免：
1. 系统中会有put、delete请求
2. 请求会带用户的验证信息如token
3. 一般都是用json格式

### 5. 怎么减少预检的请求次数？

> 后端在请求的返回头部添加：Access-Control-Max-Age：（number）  可以被缓存多久，单位是秒。Access-Control-Max-Age方法对完全一样的url的缓存设置生效，多一个参数也视为不同url。

#### 记忆关键点：
Access-Control-Max-Age可以设置预检请求的缓存时间

